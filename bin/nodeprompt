#!/usr/bin/env node

'use strict';

const args = require( 'optimist' ).argv;
const styles = require( '../lib/styles.js' )( false );
const configDefault = require( './../config.default.js' );
const aheadRegex = /\[ahead (\d+)/;
const behindRegex = /behind (\d+)\]/;
const branchRegex = /^(.+?)(?:(?=\.{2}| )|$)/;
const recordedInIndex = { M: 1, A: 1, D: 1, R: 1, C: 1 };
const modifiedInWorkTree = { M: 1, A: 1, U: 1, D: 1 };
const env = process.env;
const NODEPROMPT = {
	/**
	 * Re-shapes given `path` according to `config#pathLength`,
	 * and stores it in `data` object.
	 *
	 * @param {Object} data
	 * @param {String} path
	 * @param {String} home
	 */
	getPath( data, path, home ) {
		const homeRegex = new RegExp( '^' + home );
		const inHome = path.match( homeRegex );

		if ( inHome ) {
			path = path.replace( homeRegex, '' );
		}

		path = path.split( '/' );

		if ( !path[ 0 ] )
			path = path.slice( 1 );

		if ( !path[ path.length - 1 ] )
			path = path.slice( 0, -1 );

		if ( path.length > this.config.pathLength ) {
			path = path.slice( -this.config.pathLength );
			path[ 0 ] = '...' + path[ 0 ];
		}

		path = path.join( '/' );

		if ( inHome )
			path = '~' + ( path.length === 0 ? '' : '/' ) + path;
		else
			path = '/' + path;

		data.path = path;
	},

	/**
	 * Parses `git status --porcelain` output into
	 * `data` object format.
	 *
	 * @param {Object} data
	 * @param {String} status
	 */
	getStatus( data, status ) {
		const statusArray = status.split( '\n' );
		const branchLine = statusArray.shift().slice( 3 );

		data.modified = data.added = data.untracked = 0;

		if ( !data.detached && !data.init ) {
			const ahead = branchLine.match( aheadRegex );
			const behind = branchLine.match( behindRegex );

			data.ahead = ahead ? parseInt( ahead[ 1 ], 10 ) : 0;
			data.behind = behind ? parseInt( behind[ 1 ], 10 ) : 0;

			data.branch = branchLine.match( branchRegex )[ 0 ];
		}

		// See: http://git-scm.com/docs/git-status.html
		// For paths with merge conflicts, X and Y show the modification states of each side of the merge.
		// For paths that do not have merge conflicts, X shows the status of the index, and Y shows the
		// status of the work tree.
		// For untracked paths, XY are ??.
		// Other status codes can be interpreted as follows:
		// -------------------------------------------------
		// X          Y     Meaning
		// -------------------------------------------------
		//           [MD]   not updated
		// M        [ MD]   updated in index
		// A        [ MD]   added to index
		// D         [ M]   deleted from index
		// R        [ MD]   renamed in index
		// C        [ MD]   copied in index
		// [MARC]           index and work tree matches
		// [ MARC]     M    work tree changed since index
		// [ MARC]     D    deleted in work tree
		// -------------------------------------------------
		// D           D    unmerged, both deleted *
		// A           U    unmerged, added by us *
		// U           D    unmerged, deleted by them
		// U           A    unmerged, added by them *
		// D           U    unmerged, deleted by us
		// A           A    unmerged, both added
		// U           U    unmerged, both modified
		// -------------------------------------------------
		// ?           ?    untracked
		// !           !    ignored
		// -------------------------------------------------
		statusArray.forEach( item => {
			const status = item.slice( 0, 2 );

			if ( status == '??' )
				data.untracked++;
			else {
				if ( status[ 0 ] in recordedInIndex )
					data.added++;
				if ( status[ 1 ] in modifiedInWorkTree )
					data.modified++;
			}
		} );

		data.diverged = !!( data.ahead && data.behind );
	},

	/**
	 * Returns pretty `PS1` prompt string, using
	 * available data.
	 *
	 * @returns {String}
	 */
	getPS1() {
		const data = {
			// Check if not in ".git" folder (#7, #9).
			git: !!args.git && args.git !== '.' && env.PWD.indexOf( args.git ) === -1,
			host: args.host,
			user: args.user
		};

		this.getPath( data, env.PWD, env.HOME );

		if ( data.git ) {
			data.namerev = args.namerev;

			// There's no hash when inited.
			data.init = args.hash == 'HEAD';

			// .git/HEAD starts with hash when detached.
			data.detached = !args.head.match( /^ref: /g ) || args[ 'bisect-log' ];

			// .git/MERGE_HEAD is a hash of a branch when merging.
			data.merging = args[ 'merge-head' ];

			this.getStatus( data, args.status );

			data.hash = args.hash.slice( 0, this.config.hashLength );
		}

		return this.config.template( data, this.styles );
	},

	/**
	 * Default configuration object. See `config.default.js` file to know more.
	 *
	 * @property {Object}
	 */
	configDefault: configDefault,

	/**
	 * User configuration object. See `config.default.js` file to know more.
	 *
	 * @property {Object}
	 */
	configUser: null,

	/**
	 * Configuration object. See `config.default.js` file to know more.
	 *
	 * @property {Object}
	 */
	config: {},

	/**
	 * Styles object. See `config.js.tpl` file to know more.
	 *
	 * @property {Object}
	 */
	styles: styles,

	// For dev purposes only.
	args: args
};

try {
	NODEPROMPT.configUser = require(
		( env.HOME || env.HOMEPATH || env.USERPROFILE ) + '/.nodeprompt/config.user.js'
	);

	Object.assign( NODEPROMPT.config, NODEPROMPT.configDefault, NODEPROMPT.configUser );
} catch ( e ) {
	NODEPROMPT.config = NODEPROMPT.configDefault;
}

if ( module.parent ) {
	module.exports = NODEPROMPT;
} else {
	process.stdout.write( NODEPROMPT.getPS1() );
}
